name: 'Release CreamLinux'

# Run on manual dispatch with version info and release notes
on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type (patch, minor, major)'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
      custom_release_notes:
        description: 'Custom release notes (leave empty for auto-generated)'
        required: false
        type: string
      dry_run:
        description: 'Perform a dry run (no actual release)'
        required: false
        default: false
        type: boolean

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  RUST_BACKTRACE: short

jobs:
  version-bump:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Get all history for changelog

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Calculate New Version
        id: version
        run: |
          # Read current version from package.json
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          echo "Current version: $CURRENT_VERSION"

          # Split version into major.minor.patch
          IFS='.' read -r major minor patch <<< "$CURRENT_VERSION"

          # Increment based on input
          if [[ "${{ github.event.inputs.version_type }}" == "major" ]]; then
            major=$((major + 1))
            minor=0
            patch=0
          elif [[ "${{ github.event.inputs.version_type }}" == "minor" ]]; then
            minor=$((minor + 1))
            patch=0
          else # patch
            patch=$((patch + 1))
          fi

          # Create new version
          NEW_VERSION="${major}.${minor}.${patch}"
          echo "New version: $NEW_VERSION"

          # Set output for later steps
          echo "new_version=${NEW_VERSION}" >> $GITHUB_OUTPUT

      - name: Update Version in Files
        env:
          NEW_VERSION: ${{ steps.version.outputs.new_version }}
        run: |
          # Update package.json
          npm version $NEW_VERSION --no-git-tag-version

          # Update Cargo.toml
          sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" src-tauri/Cargo.toml

          # Update tauri.conf.json
          sed -i "s/\"version\": \".*\"/\"version\": \"$NEW_VERSION\"/" src-tauri/tauri.conf.json

      - name: Generate Changelog
        id: changelog
        if: github.event.inputs.custom_release_notes == ''
        run: |
          # Get all commit messages since the last tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            COMMITS=$(git log --pretty=format:"- %s" --no-merges)
          else
            COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s" --no-merges)
          fi

          # Generate changelog from commits
          CHANGELOG="## Changes\n\n$COMMITS"

          # Save changelog to a file (multiline to output)
          echo -e "$CHANGELOG" > changelog.md
          echo "Generated changelog from commit messages"

      - name: Commit Version Changes
        if: ${{ !github.event.inputs.dry_run }}
        env:
          NEW_VERSION: ${{ steps.version.outputs.new_version }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add package.json src-tauri/Cargo.toml src-tauri/tauri.conf.json
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
          git tag -a "v$NEW_VERSION" -m "Version $NEW_VERSION"
          git push origin HEAD:${GITHUB_REF#refs/heads/}
          git push origin "v$NEW_VERSION"

      # Upload changelog as an artifact for the publish-release job
      - name: Upload Changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: changelog.md
          retention-days: 1

  build-linux:
    needs: version-bump
    runs-on: ubuntu-latest
    outputs:
      appimage_path: ${{ steps.find-assets.outputs.appimage_path }}
      deb_path: ${{ steps.find-assets.outputs.deb_path }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.version-bump.outputs.new_version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'src-tauri -> target'
          cache-on-failure: true

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf

      - name: Install frontend dependencies
        run: npm install

      - name: Quick lint and type-check
        run: |
          npm run lint
          npx tsc --noEmit

      - name: Build the app (optimized)
        run: npm run tauri build

      - name: Find build assets
        id: find-assets
        run: |
          echo "appimage_path=$(find src-tauri/target/release/bundle/appimage -name "*.AppImage" | head -n 1)" >> $GITHUB_OUTPUT
          echo "deb_path=$(find src-tauri/target/release/bundle/deb -name "*.deb" | head -n 1)" >> $GITHUB_OUTPUT

      - name: Upload Linux builds as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-builds
          path: |
            ${{ steps.find-assets.outputs.appimage_path }}
            ${{ steps.find-assets.outputs.deb_path }}
          retention-days: 1

  # Build for other platforms in parallel if needed - examples:
  build-windows:
    needs: version-bump
    runs-on: windows-latest
    if: false # Disabled until we add Windows build support
    outputs:
      msi_path: ${{ steps.find-assets.outputs.msi_path }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: v${{ needs.version-bump.outputs.new_version }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: 'src-tauri -> target'
          cache-on-failure: true

      - name: Install frontend dependencies
        run: npm install

      - name: Build the app
        run: npm run tauri build

      - name: Find build assets
        id: find-assets
        shell: bash
        run: |
          echo "msi_path=$(find src-tauri/target/release/bundle/msi -name "*.msi" | head -n 1)" >> $GITHUB_OUTPUT

      - name: Upload Windows builds as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-builds
          path: |
            ${{ steps.find-assets.outputs.msi_path }}
          retention-days: 1

  # Final job to create the release and upload assets
  publish-release:
    needs: [version-bump, build-linux]
    if: ${{ !github.event.inputs.dry_run }}
    runs-on: ubuntu-latest

    steps:
      - name: Download changelog
        uses: actions/download-artifact@v4
        with:
          name: changelog

      - name: Download Linux builds
        uses: actions/download-artifact@v4
        with:
          name: linux-builds
          path: dist

      # Add this step if Windows builds are enabled
      # - name: Download Windows builds
      #   if: needs.build-windows.result == 'success'
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: windows-builds
      #     path: dist

      - name: Check downloaded artifacts
        run: |
          echo "Contents of dist directory:"
          find dist -type f | sort

      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NEW_VERSION: ${{ needs.version-bump.outputs.new_version }}
        with:
          tag_name: v${{ needs.version-bump.outputs.new_version }}
          release_name: CreamLinux v${{ needs.version-bump.outputs.new_version }}
          body_path: ${{ github.event.inputs.custom_release_notes == '' && 'changelog.md' || github.event.inputs.custom_release_notes }}
          draft: false
          prerelease: false

      - name: Get filenames
        id: get_filenames
        run: |
          echo "appimage_filename=$(basename $(find dist -name '*.AppImage' | head -n 1))" >> $GITHUB_OUTPUT
          echo "deb_filename=$(basename $(find dist -name '*.deb' | head -n 1))" >> $GITHUB_OUTPUT

      - name: Upload AppImage to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./dist/${{ steps.get_filenames.outputs.appimage_filename }}
          asset_name: CreamLinux-${{ needs.version-bump.outputs.new_version }}.AppImage
          asset_content_type: application/octet-stream

      - name: Upload Debian Package to release
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./dist/${{ steps.get_filenames.outputs.deb_filename }}
          asset_name: creamlinux_${{ needs.version-bump.outputs.new_version }}_amd64.deb
          asset_content_type: application/vnd.debian.binary-package
